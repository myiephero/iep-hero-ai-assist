REPLIT AGENT PROMPT â€” Step 3: Harden POST /api/documents + Add Diagnostics

Goal: Eliminate the 401 on POST /api/documents, accept both document and file field names, and add a tiny diagnostics surface so we can verify the code path is actually running in production. Also bump the SW/version to defeat any cache ghosts.

Do all of the following edits and then restart the app:
	1.	server/middleware/auth.ts

	â€¢	Ensure we export requireAuth and it logs:

// add near the top
const BUILD_ID = process.env.BUILD_ID || `dev-${Date.now()}`;
// inside requireAuth after verifying the user:
console.log("[DOCS AUTH DEBUG]", {
  userId: user.id,
  method: req.method,
  path: req.path,
  build: BUILD_ID
});

(Keep existing logic; just ensure this log exists.)

	2.	server/middleware/upload.ts (create if missing)

	â€¢	Create a shared Multer instance:

import multer from "multer";
const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 25 * 1024 * 1024 } // 25MB
});
export default upload;



	3.	server/routes.ts

	â€¢	At top, add:

import upload from "./middleware/upload";
const BUILD_ID = process.env.BUILD_ID || `dev-${Date.now()}`;


	â€¢	Replace the existing POST /api/documents handler to accept BOTH field names and to log clearly:

app.post(
  "/api/documents",
  requireAuth,
  upload.fields([{ name: "document", maxCount: 1 }, { name: "file", maxCount: 1 }]),
  async (req, res) => {
    try {
      // NOTE: accept either "document" or "file"
      const files: any = req.files || {};
      const doc =
        (files.document && files.document[0]) ||
        (files.file && files.file[0]);

      console.log("[DOCS UPLOAD DEBUG] hit", {
        path: req.path,
        method: req.method,
        hasFiles: !!req.files,
        fileFields: Object.keys(files || {}),
        build: BUILD_ID
      });

      if (!doc) {
        console.error("[DOCS UPLOAD ERROR] no file provided", { build: BUILD_ID });
        return res.status(400).json({ error: "No file provided (expected field 'document' or 'file')" });
      }

      // TODO: keep existing persistence logic; leave as-is below this comment.
      // Make sure we return success JSON so the client can confirm:
      // return res.status(201).json({ success: true, documentId, document });

      return res.status(201).json({
        success: true,
        debug: {
          originalname: doc.originalname,
          mimetype: doc.mimetype,
          size: doc.size,
          fieldnameUsed: doc.fieldname,
          build: BUILD_ID
        }
      });
    } catch (err) {
      console.error("[DOCS UPLOAD ERROR]", err);
      return res.status(500).json({ error: "Upload failed" });
    }
  }
);


	â€¢	Add diagnostic endpoints to confirm live code + auth path:

app.get("/__diag", (req, res) => {
  res.type("json").send({
    ok: true,
    build: BUILD_ID,
    time: new Date().toISOString(),
    pid: process.pid
  });
});

// Tiny HTML form to test uploads from the browser
app.get("/__diag/form", (_req, res) => {
  res.type("html").send(`
    <h1>Upload Diag (BUILD: ${BUILD_ID})</h1>
    <p>Try both fields. Both should work.</p>
    <form action="/api/documents" method="post" enctype="multipart/form-data">
      <div><label>document:</label> <input type="file" name="document" /></div>
      <div><label>file:</label> <input type="file" name="file" /></div>
      <button type="submit">POST /api/documents</button>
    </form>
  `);
});

// Auth + echo logger to prove requests reach server
app.post("/api/_diag/documents", requireAuth, upload.any(), (req, res) => {
  console.log("[DOCS DIAG DEBUG] /api/_diag/documents", {
    method: req.method,
    path: req.path,
    files: (req as any).files?.map((f: any) => f.fieldname),
    build: BUILD_ID
  });
  res.json({ ok: true, fields: (req as any).files?.map((f: any) => f.fieldname) || [], build: BUILD_ID });
});



	4.	client/src/components/modals/file-upload-modal.tsx

	â€¢	Ensure the upload uses our shared apiRequest helper (which injects the Bearer token) and uses field name "document" when appending the file:

const formData = new FormData();
formData.append("document", selectedFile); // IMPORTANT: "document"
// ... then: await apiRequest("/api/documents", { method: "POST", body: formData });
console.log("[DOCS UPLOAD DEBUG] sending", {
  name: selectedFile?.name,
  size: selectedFile?.size,
  type: selectedFile?.type
});



	5.	client/public/sw.js

	â€¢	Bump a visible version string and reconfirm bypass of all /api/ and all nonâ€‘GET:

// at top:
const SW_VERSION = "v-docs-auth-004";
console.error("ðŸš¨ SW ACTIVE", SW_VERSION);

self.addEventListener("fetch", (event) => {
  const { request } = event;
  // Bypass ALL API + ALL nonâ€‘GET to avoid interfering with uploads
  if (request.method !== "GET" || new URL(request.url).pathname.startsWith("/api/")) {
    return; // do not intercept
  }
  // ... leave rest of cache-first GET logic unchanged ...
});



	6.	client/src/main.tsx (or your top-level entry)

	â€¢	Emit a hardâ€‘toâ€‘miss build log:

const BUILD_ID = import.meta.env?.VITE_BUILD_ID || `time-${Date.now()}`;
console.error("ðŸš¨ EMERGENCY CACHE BUST - BUILD_ID=", BUILD_ID);



	7.	env

	â€¢	In .env (or Replit Secrets), add:

BUILD_ID=step3-docs-accept-both-fields
VITE_BUILD_ID=step3-docs-accept-both-fields



	8.	Restart the app (clean build) and confirm the console shows the new BUILD_ID and SW version.

After restart, do NOT change anything else. Reply when done.

â¸»